这两天做了很多实验，包括直接jmp绝对地址，自己操作rsp和rbp把栈移到堆上，打印栈，修改栈来改变函数返回值，确认了一些可能性。

顺便把运行时的结构在脑子里想好了。

没有编译器写的很蹩脚。。没法估计函数使用的栈大小，就只能写有栈协程了。
理论上可以直接运行时parse汇编代码，但是感觉这样做很麻烦。

先把周边的东西写好测试好了，比如一些基本的数据结构，链表什么的

写了一个泛型Chanle，真好玩，还用了很复杂的宏来实现函数重载，即使学会了看起来也感觉像魔法一样 (channel测试在test3.c)

目前探索到的系统调用规律：
前六个基本类型参数放寄存器里传递。
自定义类型参数 和 第七个以及后面的所有基本类型参数，都按顺序在栈中传递。

第i个基本类型参数是指，在所有基本类型参数中的第i个，比如:
int a1, int a2, T a3, int a4 //T是自定义类型
                        ^
                这算是第三个基本类型参数

这样如果要实现go(func, arg1, arg2, ...)的函数的话，还要用宏来判断arg哪些是自定义类型哪些是基本类型，然后分别展开到不同的重载函数

虽然用C11新加的那个_Generic关键字好像的确可以写，但是。。感觉好麻烦，还是先把arg都当成基本类型来做好了。。

C的宏编程真是个残废，还是rust大法好

遇到了16字节栈对齐问题。

第一次执行协程恢复上下文，前6个参数的保存要用纯汇编写。

用宏写了汇编代码 好爽

用参数恢复内存的栈的部分写好了！也测试好了!

完成了初始化协程、第一次运行一个协程这两个函数的编写和测试之后一下又加了很多函数，然后调试的很痛苦

后来只加了一个中途保存协程上下文和中途恢复上下文的函数调试，艰难的调好了，不过比之前的调试容易多了。。

果然步子迈得太大容易扯着蛋qwq